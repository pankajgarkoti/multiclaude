#!/bin/bash
#═══════════════════════════════════════════════════════════════════════════════
# MULTICLAUDE - Parallel Claude Development Orchestrator
#═══════════════════════════════════════════════════════════════════════════════

set -e

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")")" && pwd)"
VERSION="1.0.0"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'
BOLD='\033[1m'
DIM='\033[2m'

print_banner() {
    printf "${CYAN}multiclaude${NC} v${VERSION}\n"
}

print_usage() {
    printf "${BOLD}Usage:${NC}\n"
    printf "  ${CYAN}multiclaude new [name]${NC}              Create new project (interactive)\n"
    printf "  ${CYAN}multiclaude new -f <brief.txt>${NC}      Create project from brief file\n"
    printf "  ${CYAN}multiclaude add <feature>${NC}           Add feature to current project\n"
    printf "  ${CYAN}multiclaude add -f <brief.txt>${NC}      Add feature from brief file\n"
    printf "  ${CYAN}multiclaude run [path] [--auto-pr]${NC}  Launch agent session\n"
    printf "  ${CYAN}multiclaude status [path]${NC}           Show worker/project status\n"
    printf "  ${CYAN}multiclaude attach [path]${NC}           Attach to tmux session\n"
    printf "  ${CYAN}multiclaude monitor [path]${NC}          Restart dashboard in session\n"
    echo ""
    printf "${BOLD}Options:${NC}\n"
    printf "  ${DIM}--auto-pr${NC}    Create GitHub PR when QA passes (requires gh CLI)\n"
    printf "  ${DIM}-f, --from-file${NC}  Read project/feature details from file\n"
    printf "  ${DIM}-h, --help${NC}   Show this help\n"
    printf "  ${DIM}-v, --version${NC} Show version\n"
}

cmd_new() {
    local name=""
    local from_file=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --from-file|-f)
                from_file="$2"
                shift 2
                ;;
            *)
                [[ -z "$name" ]] && name="$1"
                shift
                ;;
        esac
    done

    print_banner

    if [[ -n "$from_file" ]]; then
        # Non-interactive mode
        "$SCRIPT_DIR/bootstrap.sh" --from-file "$from_file"
    else
        # Interactive mode (existing)
        if [[ -z "$name" ]]; then
            printf "${YELLOW}Project name:${NC} "
            read -r name
        fi

        if [[ -z "$name" ]]; then
            printf "${RED}Error: Project name required${NC}\n"
            exit 1
        fi

        printf "${BOLD}Creating project: ${name}${NC}\n"
        echo ""

        # Run bootstrap with project name pre-filled
        "$SCRIPT_DIR/bootstrap.sh" --name "$name"
    fi
}

cmd_run() {
    local path="."
    local auto_pr=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --auto-pr)
                auto_pr="true"
                shift
                ;;
            *)
                path="$1"
                shift
                ;;
        esac
    done

    print_banner

    # Check if path is a valid project
    if [[ ! -d "$path/specs" ]] && [[ ! -d "$path/.claude" ]]; then
        printf "${RED}Error: Not a valid project directory${NC}\n"
        echo "Run 'multiclaude new <name>' to create a project first."
        exit 1
    fi

    AUTO_PR="$auto_pr" "$SCRIPT_DIR/loop.sh" "$path"
}

cmd_attach() {
    local path="${1:-.}"

    # Resolve absolute path
    if [[ -d "$path" ]]; then
        path="$(cd "$path" && pwd)"
    else
        printf "${RED}Error: Project path does not exist: $path${NC}\n"
        exit 1
    fi

    local project_name="$(basename "$path")"
    local session_name="claude-${project_name}"

    if tmux has-session -t "$session_name" 2>/dev/null; then
        tmux attach -t "$session_name"
    else
        printf "${RED}Error: No tmux session found: $session_name${NC}\n"
        echo ""
        echo "Run 'multiclaude run $path' to start the agent session first."
        exit 1
    fi
}

cmd_add() {
    local feature=""
    local from_file=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --from-file|-f)
                from_file="$2"
                shift 2
                ;;
            *)
                [[ -z "$feature" ]] && feature="$1"
                shift
                ;;
        esac
    done

    if [[ -n "$from_file" ]]; then
        "$SCRIPT_DIR/feature.sh" "." --from-file "$from_file"
    else
        # Existing interactive behavior
        if [[ -z "$feature" ]]; then
            printf "${RED}Error: Feature name required${NC}\n"
            echo "Usage: multiclaude add <feature-name>"
            echo "       multiclaude add --from-file <brief.txt>"
            exit 1
        fi
        "$SCRIPT_DIR/feature.sh" "." "$feature"
    fi
}

cmd_status() {
    local path="${1:-.}"

    # Resolve absolute path
    if [[ -d "$path" ]]; then
        path="$(cd "$path" && pwd)"
    else
        printf "${RED}Error: Project path does not exist: $path${NC}\n"
        exit 1
    fi

    local project_name="$(basename "$path")"
    local session_name="claude-${project_name}"

    printf "${CYAN}═══════════════════════════════════════════════════════════════${NC}\n"
    printf "${BOLD}         Agent Status - ${project_name}${NC}\n"
    printf "${CYAN}═══════════════════════════════════════════════════════════════${NC}\n"
    echo ""

    # Check tmux session
    if tmux has-session -t "$session_name" 2>/dev/null; then
        printf "tmux session: ${GREEN}${session_name} (running)${NC}\n"

        # Show windows
        printf "\n${BOLD}Windows:${NC}\n"
        tmux list-windows -t "$session_name" 2>/dev/null | while read line; do
            printf "  $line\n"
        done
    else
        printf "tmux session: ${RED}${session_name} (not running)${NC}\n"
        echo ""
        echo "Run 'multiclaude run $path' to start the agent session."
    fi
    echo ""

    # Check communication files
    printf "${BOLD}Communication Files:${NC}\n"
    if [[ -f "$path/.claude/supervisor-inbox.md" ]]; then
        local lines=$(wc -l < "$path/.claude/supervisor-inbox.md" | tr -d ' ')
        printf "  Supervisor inbox: ${GREEN}exists${NC} ($lines lines)\n"
    else
        printf "  Supervisor inbox: ${RED}missing${NC}\n"
    fi

    if [[ -f "$path/.claude/qa-inbox.md" ]]; then
        local lines=$(wc -l < "$path/.claude/qa-inbox.md" | tr -d ' ')
        printf "  QA inbox:         ${GREEN}exists${NC} ($lines lines)\n"
    else
        printf "  QA inbox:         ${RED}missing${NC}\n"
    fi
    echo ""

    # Check for worktrees
    if [[ ! -d "$path/worktrees" ]]; then
        echo "No worktrees found. Features not yet set up."
        exit 0
    fi

    printf "${BOLD}Worker Status:${NC}\n"
    printf "%-15s %-12s %s\n" "FEATURE" "STATUS" "MESSAGE"
    echo "─────────────────────────────────────────────────────────────────"

    local total=0
    local complete=0
    local in_progress=0

    for worktree in "$path"/worktrees/feature-*; do
        if [[ -d "$worktree" ]]; then
            ((total++))
            local feature=$(basename "$worktree" | sed 's/feature-//')
            local log="$worktree/.claude/status.log"

            if [[ -f "$log" ]]; then
                local last=$(grep -E '\[(PENDING|IN_PROGRESS|BLOCKED|TESTING|COMPLETE|FAILED)\]' "$log" 2>/dev/null | tail -1)
                local status=$(echo "$last" | grep -oE '\[(PENDING|IN_PROGRESS|BLOCKED|TESTING|COMPLETE|FAILED)\]' | tr -d '[]')
                local msg=$(echo "$last" | sed 's/.*\] //' | cut -c1-35)

                case "$status" in
                    COMPLETE)    color="${GREEN}"; ((complete++)) ;;
                    IN_PROGRESS) color="${YELLOW}"; ((in_progress++)) ;;
                    TESTING)     color="${CYAN}" ;;
                    BLOCKED|FAILED) color="${RED}" ;;
                    *)           color="${NC}" ;;
                esac

                printf "%-15s ${color}%-12s${NC} %s\n" "$feature" "$status" "$msg"
            else
                printf "%-15s ${RED}%-12s${NC}\n" "$feature" "NO_LOG"
            fi
        fi
    done

    echo "─────────────────────────────────────────────────────────────────"
    printf "Total: $total | ${GREEN}Complete: $complete${NC} | ${YELLOW}In Progress: $in_progress${NC}\n"
    echo ""

    # Check for completion markers
    if [[ -f "$path/.claude/PROJECT_COMPLETE" ]]; then
        printf "${GREEN}╔════════════════════════════════════════╗${NC}\n"
        printf "${GREEN}║         PROJECT COMPLETE!              ║${NC}\n"
        printf "${GREEN}╚════════════════════════════════════════╝${NC}\n"
    elif [[ -f "$path/.claude/QA_COMPLETE" ]]; then
        printf "${GREEN}QA has passed. Awaiting final completion.${NC}\n"
    elif [[ -f "$path/.claude/QA_NEEDS_FIXES" ]]; then
        printf "${YELLOW}QA found issues. Workers should check their inboxes.${NC}\n"
    elif [[ -f "$path/.claude/ALL_MERGED" ]]; then
        printf "${CYAN}All features merged. QA should be running.${NC}\n"
    fi
    echo ""
}

cmd_monitor() {
    local path="${1:-.}"

    # Resolve absolute path
    if [[ -d "$path" ]]; then
        path="$(cd "$path" && pwd)"
    else
        printf "${RED}Error: Project path does not exist: $path${NC}\n"
        exit 1
    fi

    local project_name="$(basename "$path")"
    local session_name="claude-${project_name}"

    if ! tmux has-session -t "$session_name" 2>/dev/null; then
        printf "${RED}Error: No tmux session found: $session_name${NC}\n"
        echo "Run 'multiclaude run $path' to start the agent session first."
        exit 1
    fi

    # Find the first window (could be 0 or 1 depending on base-index)
    local first_window
    first_window=$(tmux list-windows -t "$session_name" -F '#{window_index}' | head -1)

    printf "${CYAN}Restarting monitor in $session_name:$first_window...${NC}\n"
    tmux send-keys -t "$session_name:$first_window" C-c
    sleep 0.5
    tmux send-keys -t "$session_name:$first_window" "$SCRIPT_DIR/monitor.sh '$path'" Enter
    tmux attach -t "$session_name:$first_window"
}

cmd_install() {
    "$SCRIPT_DIR/install.sh"
}

# Parse command
case "${1:-}" in
    new|create|init)
        shift
        cmd_new "$@"
        ;;
    run|start|loop)
        shift
        cmd_run "$@"
        ;;
    attach|a)
        shift
        cmd_attach "$@"
        ;;
    add|feature)
        shift
        cmd_add "$@"
        ;;
    status|ps)
        shift
        cmd_status "$@"
        ;;
    monitor|mon)
        shift
        cmd_monitor "$@"
        ;;
    install)
        cmd_install
        ;;
    -v|--version)
        echo "multiclaude v${VERSION}"
        ;;
    -h|--help|help|"")
        print_banner
        print_usage
        ;;
    *)
        printf "${RED}Unknown command: $1${NC}\n"
        echo ""
        print_usage
        exit 1
        ;;
esac
