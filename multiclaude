#!/bin/bash
#═══════════════════════════════════════════════════════════════════════════════
# MULTICLAUDE - Parallel Claude Development Orchestrator
#═══════════════════════════════════════════════════════════════════════════════

set -e

# Portable symlink resolution (works on macOS without coreutils)
_resolve_symlink() {
    local path="$1"
    while [[ -L "$path" ]]; do
        local dir="$(dirname "$path")"
        path="$(readlink "$path")"
        [[ "$path" != /* ]] && path="$dir/$path"
    done
    echo "$path"
}

SCRIPT_DIR="$(cd "$(dirname "$(_resolve_symlink "${BASH_SOURCE[0]}")")" && pwd)"
source "$SCRIPT_DIR/common.sh"

# Global flags
VERBOSE=""
DRY_RUN=""

# Helper functions
log_verbose() {
    [[ "$VERBOSE" == "true" ]] && printf "${DIM}[verbose] %s${NC}\n" "$1"
}

validate_project_name() {
    local name="$1"
    if [[ ! "$name" =~ ^[a-zA-Z][a-zA-Z0-9_-]*$ ]]; then
        printf "${RED}Error: Invalid name '%s'${NC}\n" "$name"
        echo "Names must start with a letter and contain only letters, numbers, hyphens, underscores."
        exit 1
    fi
    # Check length
    if [[ ${#name} -gt 64 ]]; then
        printf "${RED}Error: Name too long (max 64 chars)${NC}\n"
        exit 1
    fi
}

print_banner() {
    printf "${CYAN}multiclaude${NC} v${VERSION}\n"
}

print_usage() {
    printf "${BOLD}Usage:${NC}\n"
    printf "  ${CYAN}multiclaude new [name]${NC}              Create new project\n"
    printf "  ${CYAN}multiclaude new .${NC}                   Create in current directory\n"
    printf "  ${CYAN}multiclaude new -f <brief.txt>${NC}      Create from brief file\n"
    printf "  ${CYAN}multiclaude add <feature>${NC}           Add feature to project\n"
    printf "  ${CYAN}multiclaude add -f <brief.txt>${NC}      Add feature from brief\n"
    printf "  ${CYAN}multiclaude run [path] [--auto-pr]${NC}  Launch agent session\n"
    printf "  ${CYAN}multiclaude stop [path]${NC}             Stop agent session\n"
    printf "  ${CYAN}multiclaude status [path]${NC}           Show worker status\n"
    printf "  ${CYAN}multiclaude logs [path]${NC}             View logs/mailbox\n"
    printf "  ${CYAN}multiclaude attach [path]${NC}           Attach to tmux session\n"
    printf "  ${CYAN}multiclaude monitor [path]${NC}          Restart dashboard\n"
    printf "  ${CYAN}multiclaude install${NC}                 Install/update multiclaude\n"
  printf "  ${CYAN}multiclaude update${NC}                  Self-update from remote\n"
    echo ""
    printf "${BOLD}Options:${NC}\n"
    printf "  ${DIM}--auto-pr${NC}        Create GitHub PR when QA passes\n"
    printf "  ${DIM}-f, --from-file${NC}  Read details from file\n"
    printf "  ${DIM}-V, --verbose${NC}    Show detailed output\n"
    printf "  ${DIM}-n, --dry-run${NC}    Preview without executing\n"
    printf "  ${DIM}-h, --help${NC}       Show this help\n"
    printf "  ${DIM}-v, --version${NC}    Show version\n"
}

cmd_new() {
    local name=""
    local from_file=""
    local use_current_dir=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --from-file|-f)
                from_file="$2"
                shift 2
                ;;
            .)
                use_current_dir="true"
                shift
                ;;
            *)
                [[ -z "$name" ]] && name="$1"
                shift
                ;;
        esac
    done

    print_banner

    _show_next_steps() {
        local dir="$1"
        echo ""
        printf "${BOLD}Next step:${NC} run ${CYAN}multiclaude run ${dir}${NC} to start development\n"
        echo ""
    }

    if [[ -n "$from_file" ]]; then
        # Non-interactive mode - use current directory
        "$SCRIPT_DIR/bootstrap.sh" --from-file "$from_file" --dir "$(pwd)"
        _show_next_steps "."
    elif [[ -n "$use_current_dir" ]]; then
        # Use current directory
        local dir_name="$(basename "$(pwd)")"
        printf "${BOLD}Creating project in current directory: ${dir_name}${NC}\n"
        echo ""
        "$SCRIPT_DIR/bootstrap.sh" --name "$dir_name" --dir "$(pwd)"
        _show_next_steps "."
    else
        # Interactive mode - let bootstrap.sh handle all prompts
        local args=()
        if [[ -n "$name" ]]; then
            args+=(--name "$name")
        fi
        "$SCRIPT_DIR/bootstrap.sh" "${args[@]}"
        _show_next_steps "${name:-.}"
    fi
}

cmd_run() {
    local path="."
    local auto_pr=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --auto-pr)
                auto_pr="true"
                shift
                ;;
            *)
                path="$1"
                shift
                ;;
        esac
    done

    print_banner

    # Check if path is a valid project
    if [[ ! -d "$path/.multiclaude/specs" ]] && [[ ! -d "$path/.multiclaude" ]]; then
        printf "${RED}Error: Not a valid project directory${NC}\n"
        echo "Run 'multiclaude new <name>' to create a project first."
        exit 1
    fi

    AUTO_PR="$auto_pr" "$SCRIPT_DIR/loop.sh" "$path"
}

cmd_attach() {
    local path="${1:-.}"

    # Resolve absolute path
    if [[ -d "$path" ]]; then
        path="$(cd "$path" && pwd)"
    else
        printf "${RED}Error: Project path does not exist: %s${NC}\n" "$path"
        exit 1
    fi

    local project_name="$(basename "$path")"
    local session_name="claude-${project_name}"

    if tmux has-session -t "$session_name" 2>/dev/null; then
        tmux attach -t "$session_name"
    else
        printf "${RED}Error: No tmux session found: %s${NC}\n" "$session_name"
        echo ""
        echo "Run 'multiclaude run $path' to start the agent session first."
        exit 1
    fi
}

cmd_add() {
    local feature=""
    local from_file=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --from-file|-f)
                from_file="$2"
                shift 2
                ;;
            *)
                [[ -z "$feature" ]] && feature="$1"
                shift
                ;;
        esac
    done

    if [[ -n "$from_file" ]]; then
        "$SCRIPT_DIR/feature.sh" "." --from-file "$from_file"
    else
        # Existing interactive behavior
        if [[ -z "$feature" ]]; then
            printf "${RED}Error: Feature name required${NC}\n"
            echo "Usage: multiclaude add <feature-name>"
            echo "       multiclaude add --from-file <brief.txt>"
            exit 1
        fi
        "$SCRIPT_DIR/feature.sh" "." "$feature"
    fi
}

cmd_status() {
    local path="${1:-.}"

    # Resolve absolute path
    if [[ -d "$path" ]]; then
        path="$(cd "$path" && pwd)"
    else
        printf "${RED}Error: Project path does not exist: %s${NC}\n" "$path"
        exit 1
    fi

    local project_name="$(basename "$path")"
    local session_name="claude-${project_name}"

    printf "${CYAN}═══════════════════════════════════════════════════════════════${NC}\n"
    printf "${BOLD}         Agent Status - ${project_name}${NC}\n"
    printf "${CYAN}═══════════════════════════════════════════════════════════════${NC}\n"
    echo ""

    # Check tmux session
    if tmux has-session -t "$session_name" 2>/dev/null; then
        printf "tmux session: ${GREEN}${session_name} (running)${NC}\n"

        # Show windows
        printf "\n${BOLD}Windows:${NC}\n"
        tmux list-windows -t "$session_name" 2>/dev/null | while read line; do
            printf "  $line\n"
        done
    else
        printf "tmux session: ${RED}${session_name} (not running)${NC}\n"
        echo ""
        echo "Run 'multiclaude run $path' to start the agent session."
    fi
    echo ""

    # Check communication files
    printf "${BOLD}Communication Files:${NC}\n"
    if [[ -f "$path/.multiclaude/supervisor-inbox.md" ]]; then
        local lines=$(wc -l < "$path/.multiclaude/supervisor-inbox.md" | tr -d ' ')
        printf "  Supervisor inbox: ${GREEN}exists${NC} ($lines lines)\n"
    else
        printf "  Supervisor inbox: ${RED}missing${NC}\n"
    fi

    if [[ -f "$path/.multiclaude/qa-inbox.md" ]]; then
        local lines=$(wc -l < "$path/.multiclaude/qa-inbox.md" | tr -d ' ')
        printf "  QA inbox:         ${GREEN}exists${NC} ($lines lines)\n"
    else
        printf "  QA inbox:         ${RED}missing${NC}\n"
    fi
    echo ""

    # Check for worktrees
    if [[ ! -d "$path/.multiclaude/worktrees" ]]; then
        echo "No worktrees found. Features not yet set up."
        exit 0
    fi

    printf "${BOLD}Worker Status:${NC}\n"
    printf "%-15s %-12s %s\n" "FEATURE" "STATUS" "MESSAGE"
    echo "─────────────────────────────────────────────────────────────────"

    local total=0
    local complete=0
    local in_progress=0

    for worktree in "$path"/.multiclaude/worktrees/feature-*; do
        if [[ -d "$worktree" ]]; then
            ((total++))
            local feature=$(basename "$worktree" | sed 's/feature-//')
            local log="$worktree/.multiclaude/status.log"

            if [[ -f "$log" ]]; then
                local last=$(grep -E '\[(PENDING|IN_PROGRESS|BLOCKED|TESTING|COMPLETE|FAILED)\]' "$log" 2>/dev/null | tail -1)
                local status=$(echo "$last" | grep -oE '\[(PENDING|IN_PROGRESS|BLOCKED|TESTING|COMPLETE|FAILED)\]' | tr -d '[]')
                local msg=$(echo "$last" | sed 's/.*\] //' | cut -c1-35)

                case "$status" in
                    COMPLETE)    color="${GREEN}"; ((complete++)) ;;
                    IN_PROGRESS) color="${YELLOW}"; ((in_progress++)) ;;
                    TESTING)     color="${CYAN}" ;;
                    BLOCKED|FAILED) color="${RED}" ;;
                    *)           color="${NC}" ;;
                esac

                printf "%-15s ${color}%-12s${NC} %s\n" "$feature" "$status" "$msg"
            else
                printf "%-15s ${RED}%-12s${NC}\n" "$feature" "NO_LOG"
            fi
        fi
    done

    echo "─────────────────────────────────────────────────────────────────"
    printf "Total: $total | ${GREEN}Complete: $complete${NC} | ${YELLOW}In Progress: $in_progress${NC}\n"
    echo ""

    # Check for completion markers
    if [[ -f "$path/.multiclaude/PROJECT_COMPLETE" ]]; then
        printf "${GREEN}╔════════════════════════════════════════╗${NC}\n"
        printf "${GREEN}║         PROJECT COMPLETE!              ║${NC}\n"
        printf "${GREEN}╚════════════════════════════════════════╝${NC}\n"
    elif [[ -f "$path/.multiclaude/QA_COMPLETE" ]]; then
        printf "${GREEN}QA has passed. Awaiting final completion.${NC}\n"
    elif [[ -f "$path/.multiclaude/QA_NEEDS_FIXES" ]]; then
        printf "${YELLOW}QA found issues. Workers should check their inboxes.${NC}\n"
    elif [[ -f "$path/.multiclaude/ALL_MERGED" ]]; then
        printf "${CYAN}All features merged. QA should be running.${NC}\n"
    fi
    echo ""
}

cmd_monitor() {
    local path="${1:-.}"

    # Resolve absolute path
    if [[ -d "$path" ]]; then
        path="$(cd "$path" && pwd)"
    else
        printf "${RED}Error: Project path does not exist: %s${NC}\n" "$path"
        exit 1
    fi

    local project_name="$(basename "$path")"
    local session_name="claude-${project_name}"

    if ! tmux has-session -t "$session_name" 2>/dev/null; then
        printf "${RED}Error: No tmux session found: %s${NC}\n" "$session_name"
        echo "Run 'multiclaude run $path' to start the agent session first."
        exit 1
    fi

    # Find the first window (could be 0 or 1 depending on base-index)
    local first_window
    first_window=$(tmux list-windows -t "$session_name" -F '#{window_index}' | head -1)

    printf "${CYAN}Restarting monitor in %s:%s...${NC}\n" "$session_name" "$first_window"
    tmux send-keys -t "$session_name:$first_window" C-c
    sleep 0.5
    tmux send-keys -t "$session_name:$first_window" "$SCRIPT_DIR/monitor.sh '$path'" Enter
    tmux attach -t "$session_name:$first_window"
}

cmd_stop() {
    local path="${1:-.}"

    if [[ -d "$path" ]]; then
        path="$(cd "$path" && pwd)"
    else
        printf "${RED}Error: Project path does not exist: %s${NC}\n" "$path"
        exit 1
    fi

    local project_name="$(basename "$path")"
    local session_name="claude-${project_name}"

    if tmux has-session -t "$session_name" 2>/dev/null; then
        tmux kill-session -t "$session_name"
        printf "${GREEN}Stopped session: %s${NC}\n" "$session_name"
    else
        printf "${YELLOW}No running session: %s${NC}\n" "$session_name"
    fi
}

cmd_logs() {
    local path="."
    local follow=""
    local agent=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f|--follow) follow="true"; shift ;;
            --agent|-a) agent="$2"; shift 2 ;;
            *) path="$1"; shift ;;
        esac
    done

    if [[ -d "$path" ]]; then
        path="$(cd "$path" && pwd)"
    else
        printf "${RED}Error: Project path does not exist: %s${NC}\n" "$path"
        exit 1
    fi

    print_banner

    if [[ -n "$agent" ]]; then
        local log_file="$path/.multiclaude/worktrees/feature-$agent/.multiclaude/status.log"
        if [[ ! -f "$log_file" ]]; then
            printf "${RED}Error: No log for agent: %s${NC}\n" "$agent"
            echo "Available agents:"
            for wt in "$path"/.multiclaude/worktrees/feature-*; do
                [[ -d "$wt" ]] && echo "  - $(basename "$wt" | sed 's/feature-//')"
            done
            exit 1
        fi
    else
        local log_file="$path/.multiclaude/mailbox"
        if [[ ! -f "$log_file" ]]; then
            printf "${YELLOW}No mailbox found. Showing worker status logs:${NC}\n\n"
            for wt in "$path"/.multiclaude/worktrees/feature-*; do
                if [[ -d "$wt" ]]; then
                    local feat=$(basename "$wt" | sed 's/feature-//')
                    printf "${CYAN}=== %s ===${NC}\n" "$feat"
                    tail -5 "$wt/.multiclaude/status.log" 2>/dev/null || echo "(no log)"
                    echo ""
                fi
            done
            exit 0
        fi
    fi

    if [[ "$follow" == "true" ]]; then
        tail -f "$log_file"
    else
        tail -50 "$log_file"
    fi
}

cmd_install() {
    "$SCRIPT_DIR/install.sh"
}

cmd_update() {
    printf "${CYAN}Updating multiclaude...${NC}\n"
    curl -fsSL https://raw.githubusercontent.com/pankajgarkoti/multiclaude/main/remote-install.sh | bash
}

# Parse global flags
while [[ $# -gt 0 ]]; do
    case "$1" in
        --verbose|-V) VERBOSE="true"; shift ;;
        --dry-run|-n) DRY_RUN="true"; shift ;;
        *) break ;;
    esac
done
export VERBOSE DRY_RUN

# Parse command
case "${1:-}" in
    new|init)
        shift
        cmd_new "$@"
        ;;
    run)
        shift
        cmd_run "$@"
        ;;
    stop)
        shift
        cmd_stop "$@"
        ;;
    attach)
        shift
        cmd_attach "$@"
        ;;
    add)
        shift
        cmd_add "$@"
        ;;
    status)
        shift
        cmd_status "$@"
        ;;
    logs)
        shift
        cmd_logs "$@"
        ;;
    monitor)
        shift
        cmd_monitor "$@"
        ;;
    install)
        cmd_install
        ;;
    update)
        cmd_update
        ;;
    -v|--version)
        echo "multiclaude v${VERSION}"
        ;;
    -h|--help|help|"")
        print_banner
        print_usage
        ;;
    *)
        printf "${RED}Unknown command: %s${NC}\n" "$1"
        echo ""
        print_usage
        exit 1
        ;;
esac
